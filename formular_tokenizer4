import re
from typing import List, Dict, Tuple, Optional, Union


class ExcelFormulaFormatterV2:
    """Excel å…¬å¼æ ¼å¼åŒ–å¼•æ“ - é‡å¯«ç‰ˆæœ¬"""
    
    def __init__(self, indent_char: str = "    ", verbose: bool = False):
        """åˆå§‹åŒ–æ ¼å¼åŒ–å™¨"""
        self.indent_char = indent_char
        self.verbose = verbose
        self.has_at_symbol = False
        
        # Excel å‡½æ•¸åç¨±æ¸…å–®
        self.excel_functions = {
            'SUMPRODUCT', 'INDEX', 'MATCH', 'OFFSET', 'INDIRECT', 'VLOOKUP', 
            'HLOOKUP', 'IF', 'IFERROR', 'SUMIF', 'SUMIFS', 'COUNTIF', 
            'COUNTIFS', 'AVERAGEIF', 'AVERAGEIFS', 'AND', 'OR', 'NOT',
            'SUM', 'AVERAGE', 'COUNT', 'MAX', 'MIN', 'CONCATENATE',
            'LEFT', 'RIGHT', 'MID', 'LEN', 'TRIM', 'UPPER', 'LOWER',
            'LOOKUP', 'CHOOSE', 'SUBSTITUTE', 'FIND', 'SEARCH', 'TEXT',
            'VALUE', 'DATE', 'TIME', 'NOW', 'TODAY', 'YEAR', 'MONTH', 'DAY',
            'ISERROR', 'ISBLANK', 'ISNUMBER', 'ISTEXT', 'ROUND', 'ABS',
            'FILTER', 'SORT', 'SORTBY', 'UNIQUE', 'SEQUENCE', 'RANDARRAY',
            'XLOOKUP', 'XMATCH', 'LET', 'LAMBDA', 'REDUCE', 'MAP', 'SCAN',
            'BYROW', 'BYCOL', 'MAKEARRAY', 'TAKE', 'DROP', 'CHOOSEROWS',
            'CHOOSECOLS', 'EXPAND', 'TOCOL', 'TOROW', 'WRAPCOLS', 'WRAPROWS',
            'COUNTA', 'COUNTBLANK', 'PRODUCT', 'POWER', 'SQRT', 'EXP', 'LN', 'LOG',
            'LOG10', 'SIN', 'COS', 'TAN', 'ASIN', 'ACOS', 'ATAN', 'ATAN2',
            'DEGREES', 'RADIANS', 'PI', 'RAND', 'RANDBETWEEN', 'MOD', 'QUOTIENT',
            'GCD', 'LCM', 'FACT', 'COMBIN', 'PERMUT', 'CEIL', 'FLOOR', 'TRUNC',
            'INT', 'SIGN', 'EVEN', 'ODD', 'MMULT', 'TRANSPOSE', 'MDETERM', 'MINVERSE'
        }
    
    def _log_message(self, message: str) -> None:
        """è¨˜éŒ„è™•ç†è¨Šæ¯"""
        if self.verbose:
            print(f"[æ ¼å¼åŒ–å¼•æ“] {message}")
    
    def _is_external_reference(self, token: str) -> bool:
        """æª¢æ¸¬æ˜¯å¦ç‚ºå¤–éƒ¨åƒç…§"""
        patterns = [
            r"'[^']*\[[^\]]+\][^']*'![A-Z$]+\d+(?::[A-Z$]+\d+)?",
            r"'?\[[^\]]+\][^'!]*'?![A-Z$]+\d+(?::[A-Z$]+\d+)?",
            r"'[^'\[\]]+![A-Z$]+\d+(?::[A-Z$]+\d+)?'",
            r"[A-Za-z_][A-Za-z0-9_]*![A-Z$]+\d+(?::[A-Z$]+\d+)?"
        ]
        
        for pattern in patterns:
            if re.match(pattern, token, re.IGNORECASE):
                return True
        return False
    
    def tokenize_formula(self, formula: str) -> List[str]:
        """å°‡å…¬å¼æ‹†è§£æˆ tokens - æ”¹é€²ç‰ˆæœ¬"""
        if formula.startswith('='):
            formula = formula[1:]
        
        if formula.startswith('@'):
            self.has_at_symbol = True
            formula = formula[1:]
        
        tokens = []
        i = 0
        
        while i < len(formula):
            char = formula[i]
            
            # è™•ç†å¼•è™Ÿå­—ä¸²
            if char == '"':
                string_content = char
                i += 1
                while i < len(formula) and formula[i] != '"':
                    string_content += formula[i]
                    i += 1
                if i < len(formula):
                    string_content += formula[i]
                    i += 1
                tokens.append(string_content)
                continue
            
            # è™•ç†å–®å¼•è™Ÿåƒç…§
            if char == "'":
                quote_content = char
                i += 1
                while i < len(formula) and formula[i] != "'":
                    quote_content += formula[i]
                    i += 1
                if i < len(formula):
                    quote_content += formula[i]
                    i += 1
                
                # æª¢æŸ¥å¾Œé¢æ˜¯å¦æœ‰!
                if i < len(formula) and formula[i] == '!':
                    while i < len(formula) and formula[i] not in '(),':
                        quote_content += formula[i]
                        i += 1
                
                tokens.append(quote_content)
                continue
            
            # è™•ç†æ–¹æ‹¬è™Ÿ
            if char == '[':
                bracket_content = char
                i += 1
                while i < len(formula) and formula[i] != ']':
                    bracket_content += formula[i]
                    i += 1
                if i < len(formula):
                    bracket_content += formula[i]
                    i += 1
                
                # ç¹¼çºŒæ”¶é›†åˆ°åˆ†éš”ç¬¦
                while i < len(formula) and formula[i] not in '(),':
                    bracket_content += formula[i]
                    i += 1
                
                tokens.append(bracket_content)
                continue
            
            # è™•ç†æ‹¬è™Ÿå’Œé€—è™Ÿ
            if char in '(),':
                tokens.append(char)
                i += 1
                continue
            
            # è™•ç†ç©ºæ ¼
            if char.isspace():
                i += 1
                continue
            
            # è™•ç†å…¶ä»–å­—ç¬¦
            current_token = ""
            while i < len(formula) and formula[i] not in '"\'[](),':
                if formula[i].isspace():
                    break
                current_token += formula[i]
                i += 1
            
            if current_token:
                tokens.append(current_token)
        
        # å¾Œè™•ç†ï¼šåˆä½µå‡½æ•¸åç¨±å’Œæ‹¬è™Ÿï¼Œè™•ç†é‹ç®—ç¬¦
        return self._post_process_tokens(tokens)
    
    def _post_process_tokens(self, tokens: List[str]) -> List[str]:
        """å¾Œè™•ç†tokensï¼Œæ­£ç¢ºè™•ç†å‡½æ•¸å’Œé‹ç®—ç¬¦"""
        cleaned_tokens = []
        i = 0
        
        while i < len(tokens):
            token = tokens[i].strip()
            if not token:
                i += 1
                continue
            
            # å‡½æ•¸åç¨±è™•ç†
            if token.upper() in self.excel_functions:
                if i + 1 < len(tokens) and tokens[i + 1].strip() == '(':
                    cleaned_tokens.append(token + '(')
                    i += 2
                else:
                    cleaned_tokens.append(token)
                    i += 1
                continue
            
            # é‹ç®—ç¬¦è™•ç†
            if token in ['-', '+', '*', '/', '>', '<', '=']:
                # æª¢æŸ¥æ˜¯å¦ç‚ºæ•¸å­—å‰ç¶´
                if token in ['-', '+'] and i + 1 < len(tokens):
                    next_token = tokens[i + 1].strip()
                    if next_token.isdigit():
                        cleaned_tokens.append(token + next_token)
                        i += 2
                        continue
                
                # æª¢æŸ¥æ˜¯å¦ç‚ºæ¯”è¼ƒé‹ç®—ç¬¦
                if token in ['>', '<', '='] and i + 1 < len(tokens):
                    next_token = tokens[i + 1].strip()
                    if next_token.isdigit():
                        cleaned_tokens.append(token + next_token)
                        i += 2
                        continue
                    elif token == '>' and next_token == '=':
                        cleaned_tokens.append('>=')
                        i += 2
                        continue
                    elif token == '<' and next_token in ['=', '>']:
                        cleaned_tokens.append(token + next_token)
                        i += 2
                        continue
            
            cleaned_tokens.append(token)
            i += 1
        
        return cleaned_tokens
    
    def parse_formula_structure(self, tokens: List[str]) -> Optional[Dict]:
        """ä½¿ç”¨å †ç–Šæ–¹å¼è§£æå…¬å¼çµæ§‹ - å…¨æ–°å¯¦ç¾"""
        if not tokens:
            return None
        
        self._log_message(f"é–‹å§‹å †ç–Šè§£æï¼Œå…± {len(tokens)} å€‹ tokens")
        
        # ä½¿ç”¨å †ç–Šè¿½è¹¤å‡½æ•¸å±¤ç´š
        function_stack = []
        current_function = None
        current_args = []
        current_arg_tokens = []
        i = 0
        
        while i < len(tokens):
            token = tokens[i]
            self._log_message(f"è™•ç† token {i}: '{token}', å †ç–Šæ·±åº¦: {len(function_stack)}")
            
            if self._is_function_start(token):
                # å®Œæˆå‰ä¸€å€‹åƒæ•¸
                if current_arg_tokens and current_function:
                    arg_expr = self._create_expression(current_arg_tokens)
                    if arg_expr:
                        current_args.append(arg_expr)
                    current_arg_tokens = []
                
                # å»ºç«‹æ–°å‡½æ•¸
                function_name = token[:-1]
                new_function = {
                    'type': 'function',
                    'name': function_name,
                    'arguments': []
                }
                
                # å¦‚æœæœ‰ç•¶å‰å‡½æ•¸ï¼Œæ¨å…¥å †ç–Š
                if current_function:
                    function_stack.append({
                        'function': current_function,
                        'args': current_args,
                        'pending_tokens': current_arg_tokens
                    })
                
                current_function = new_function
                current_args = []
                current_arg_tokens = []
                
            elif token == ')':
                # å®Œæˆç•¶å‰åƒæ•¸
                if current_arg_tokens:
                    arg_expr = self._create_expression(current_arg_tokens)
                    if arg_expr:
                        current_args.append(arg_expr)
                    current_arg_tokens = []
                
                # å®Œæˆç•¶å‰å‡½æ•¸
                if current_function:
                    current_function['arguments'] = current_args
                    self._log_message(f"å®Œæˆå‡½æ•¸ {current_function['name']}ï¼Œåƒæ•¸æ•¸é‡: {len(current_args)}")
                    
                    # æª¢æŸ¥å †ç–Š
                    if function_stack:
                        # æ¢å¾©ä¸Šå±¤å‡½æ•¸
                        parent_context = function_stack.pop()
                        parent_function = parent_context['function']
                        parent_args = parent_context['args']
                        parent_pending = parent_context['pending_tokens']
                        
                        # å°‡å®Œæˆçš„å‡½æ•¸åŠ å…¥çˆ¶å‡½æ•¸åƒæ•¸
                        parent_args.append(current_function)
                        
                        current_function = parent_function
                        current_args = parent_args
                        current_arg_tokens = parent_pending
                    else:
                        # é€™æ˜¯æœ€å¤–å±¤å‡½æ•¸å®Œæˆ
                        # æª¢æŸ¥æ˜¯å¦æœ‰é‹ç®—ç¬¦è·Ÿåœ¨å¾Œé¢
                        if i + 1 < len(tokens):
                            next_token = tokens[i + 1]
                            if next_token in ['-', '+', '*', '/', '>', '<', '='] or next_token.startswith(('-', '+', '>', '<', '=')):
                                # å°‡å‡½æ•¸è½‰ç‚ºè¡¨é”å¼çš„ä¸€éƒ¨åˆ†
                                expr_tokens = [current_function]
                                i += 1
                                
                                # æ”¶é›†å¾ŒçºŒé‹ç®—ç¬¦å’Œæ“ä½œæ•¸
                                while i < len(tokens) and tokens[i] not in [',', ')']:
                                    expr_tokens.append(tokens[i])
                                    i += 1
                                
                                current_function = self._create_compound_expression(expr_tokens)
                                i -= 1  # èª¿æ•´ç´¢å¼•
                            else:
                                # æª¢æŸ¥æ˜¯å¦é‚„æœ‰æ›´å¤šå…§å®¹ï¼ˆå¯èƒ½æ˜¯å¦ä¸€å€‹åƒæ•¸ï¼‰
                                if i + 1 < len(tokens) and tokens[i + 1] == ',':
                                    # é€™ä¸æ˜¯æœ€çµ‚çµæœï¼Œç¹¼çºŒè™•ç†
                                    pass
                                else:
                                    # ç¢ºå¯¦æ˜¯æœ€çµ‚çµæœ
                                    return current_function
                
            elif token == ',':
                # å®Œæˆç•¶å‰åƒæ•¸
                if current_arg_tokens:
                    arg_expr = self._create_expression(current_arg_tokens)
                    if arg_expr:
                        current_args.append(arg_expr)
                    current_arg_tokens = []
                
            else:
                # æ”¶é›†åƒæ•¸tokens
                current_arg_tokens.append(token)
            
            i += 1
        
        # è™•ç†æœ€å¾Œçš„å…§å®¹
        if current_arg_tokens and current_function:
            arg_expr = self._create_expression(current_arg_tokens)
            if arg_expr:
                current_args.append(arg_expr)
        
        if current_function:
            current_function['arguments'] = current_args
        
        return current_function
    
    def _create_expression(self, tokens: List[str]) -> Optional[Dict]:
        """å‰µå»ºè¡¨é”å¼ç¯€é»"""
        if not tokens:
            return None
        
        filtered_tokens = [t.strip() for t in tokens if t.strip()]
        if not filtered_tokens:
            return None
        
        if len(filtered_tokens) == 1:
            token = filtered_tokens[0]
            if self._is_external_reference(token):
                return {'type': 'external_reference', 'value': token}
            else:
                return {'type': 'argument', 'value': token}
        else:
            # è™•ç†è¤‡åˆè¡¨é”å¼
            expression_value = ''.join(filtered_tokens)
            return {'type': 'expression', 'value': expression_value}
    
    def _create_compound_expression(self, elements: List[Union[Dict, str]]) -> Dict:
        """å‰µå»ºè¤‡åˆè¡¨é”å¼ï¼ˆå‡½æ•¸+é‹ç®—ç¬¦ï¼‰"""
        parts = []
        for element in elements:
            if isinstance(element, dict):
                if element['type'] == 'function':
                    args_str = ','.join(self._format_arg_for_expression(arg) for arg in element['arguments'])
                    parts.append(f"{element['name']}({args_str})")
                else:
                    parts.append(element['value'])
            else:
                parts.append(str(element))
        
        return {
            'type': 'expression',
            'value': ''.join(parts)
        }
    
    def _format_arg_for_expression(self, arg: Dict) -> str:
        """ç‚ºè¡¨é”å¼æ ¼å¼åŒ–åƒæ•¸"""
        if arg['type'] == 'function':
            sub_args = ','.join(self._format_arg_for_expression(sub_arg) for sub_arg in arg['arguments'])
            return f"{arg['name']}({sub_args})"
        else:
            return arg['value']
    
    def _is_function_start(self, token: str) -> bool:
        """æª¢æŸ¥æ˜¯å¦ç‚ºå‡½æ•¸é–‹å§‹"""
        if token.endswith('('):
            function_name = token[:-1]
            return function_name.upper() in self.excel_functions
        return False
    
    def format_structure_to_string(self, node: Dict, indent_level: int = 0) -> str:
        """å°‡æ¨¹ç‹€çµæ§‹æ ¼å¼åŒ–æˆå­—ä¸²"""
        if node is None:
            return ""
        
        current_indent = self.indent_char * indent_level
        
        if node['type'] == 'function':
            function_name = node['name']
            
            # åˆ¤æ–·æ˜¯å¦éœ€è¦å¤šè¡Œé¡¯ç¤º
            has_complex_args = any(
                arg['type'] in ['function', 'external_reference'] 
                for arg in node['arguments']
            )
            
            # è¤‡é›œåƒæ•¸æˆ–åƒæ•¸éå¤šæ™‚ä½¿ç”¨å¤šè¡Œæ ¼å¼
            if has_complex_args or len(node['arguments']) > 3:
                result = f"{current_indent}{function_name}(\n"
                
                # æ ¼å¼åŒ–æ¯å€‹åƒæ•¸
                for i, arg in enumerate(node['arguments']):
                    formatted_arg = self.format_structure_to_string(arg, indent_level + 1)
                    
                    if i < len(node['arguments']) - 1:
                        result += f"{formatted_arg},\n"
                    else:
                        result += f"{formatted_arg}\n"
                
                result += f"{current_indent})"
                return result
            else:
                # ç°¡å–®åƒæ•¸ä½¿ç”¨å–®è¡Œæ ¼å¼
                args_str = ', '.join(
                    self.format_structure_to_string(arg, 0).strip()
                    for arg in node['arguments']
                )
                return f"{current_indent}{function_name}({args_str})"
                
        elif node['type'] in ['external_reference', 'expression', 'argument']:
            return f"{current_indent}{node['value']}"
        
        return ""
    
    def format_excel_formula(self, formula: str) -> Tuple[str, str]:
        """æ ¼å¼åŒ– Excel å…¬å¼ï¼Œè¿”å› (åŸå§‹å…¬å¼, æ ¼å¼åŒ–çµæœ)"""
        original_formula = formula
        
        try:
            self._log_message(f"é–‹å§‹è™•ç†å…¬å¼: {formula}")
            
            self.has_at_symbol = False
            
            tokens = self.tokenize_formula(formula)
            self._log_message(f"æ‹†è§£å¾—åˆ° {len(tokens)} å€‹ç¬¦è™Ÿå–®å…ƒ")
            
            if self.verbose:
                print(f"[Debug] Tokens: {tokens}")
            
            structure = self.parse_formula_structure(tokens)
            self._log_message("çµæ§‹è§£æå®Œæˆ")
            
            if structure is None:
                raise Exception("ç„¡æ³•è§£æå…¬å¼çµæ§‹")
            
            formatted_result = self.format_structure_to_string(structure)
            
            if self.has_at_symbol:
                formatted_result = f"@{formatted_result}"
                self._log_message("å·²é‚„åŸ @ ç¬¦è™Ÿ")
            
            formatted_result = f"={formatted_result}"
            
            self._log_message("æ ¼å¼åŒ–å®Œæˆ")
            return original_formula, formatted_result
            
        except Exception as e:
            error_msg = f"æ ¼å¼åŒ–éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤: {str(e)}"
            self._log_message(f"âœ— {error_msg}")
            return original_formula, f"éŒ¯èª¤: {error_msg}"


def excel_formula_formatter_v2(formula: str, verbose: bool = False, indent_char: str = "    ") -> None:
    """Excel å…¬å¼æ ¼å¼åŒ–å¼•æ“ V2 - åŒ…å«åŸå§‹å…¬å¼å°æ¯”"""
    formatter = ExcelFormulaFormatterV2(indent_char=indent_char, verbose=verbose)
    original, formatted = formatter.format_excel_formula(formula)
    
    print("=" * 80)
    print("ğŸ“ Excel å…¬å¼æ ¼å¼åŒ–çµæœ")
    print("=" * 80)
    
    print("\nğŸ” åŸå§‹å…¬å¼:")
    print("-" * 40)
    print(original)
    
    print("\nâœ¨ æ ¼å¼åŒ–çµæœ:")
    print("-" * 40)
    print(formatted)
    
    print("\n" + "=" * 80)


def test_complex_formulas_v2():
    """æ¸¬è©¦è¤‡é›œå…¬å¼æ¡ˆä¾‹ V2"""
    
    print("ğŸ§ª æ¸¬è©¦è¤‡é›œåµŒå¥—å‡½æ•¸æ¡ˆä¾‹ V2")
    print("=" * 80)
    
    # æ¸¬è©¦æ¡ˆä¾‹ 1: åŸºæœ¬åµŒå¥—
    test_case_1 = r"""=SUMPRODUCT(INDEX('C:\Users\user\Desktop\pytest\Formula Difference Analyzer\æ–°å¢è³‡æ–™å¤¾\[e.xlsx]DataE'!B1:B10, MATCH(3, 'C:\Users\user\Desktop\pytest\Formula Difference Analyzer\æ–°å¢è³‡æ–™å¤¾\[e.xlsx]DataE'!B1:B10, 0)))"""
    
    print("\nğŸ“ æ¸¬è©¦æ¡ˆä¾‹ 1: ä¸‰å±¤åµŒå¥—å‡½æ•¸")
    excel_formula_formatter_v2(test_case_1, verbose=True)
    
    print("\n" + "-" * 60)
    
    # æ¸¬è©¦æ¡ˆä¾‹ 2: @ ç¬¦è™Ÿ
    test_case_2 = r"""=@OFFSET(INDIRECT("'[e.xlsx]DataE'!B1"),1,0)"""
    
    print("\nğŸ“ æ¸¬è©¦æ¡ˆä¾‹ 2: @ ç¬¦è™Ÿå‹•æ…‹å‡½æ•¸")
    excel_formula_formatter_v2(test_case_2, verbose=True)
    
    print("\n" + "-" * 60)
    
    # æ¸¬è©¦æ¡ˆä¾‹ 3: è¶…è¤‡é›œåµŒå¥—ï¼ˆä¸»è¦å•é¡Œæ¡ˆä¾‹ï¼‰
    test_case_3 = r"""=IF(ISERROR(INDEX(INDIRECT("'[data.xlsx]Sheet1'!A:A"),MATCH(CONCATENATE("Key",TEXT(TODAY(),"YYYY-MM-DD")),INDIRECT("'[data.xlsx]Sheet1'!B:B"),0))),SUMPRODUCT(OFFSET(INDIRECT("'[backup.xlsx]Data'!C1"),1,0,COUNTA(INDIRECT("'[backup.xlsx]Data'!C:C"))-1,1)*(INDIRECT("'[backup.xlsx]Data'!D2:D1000")>0)),INDEX(INDIRECT("'[data.xlsx]Sheet1'!A:A"),MATCH(CONCATENATE("Key",TEXT(TODAY(),"YYYY-MM-DD")),INDIRECT("'[data.xlsx]Sheet1'!B:B"),0)))"""
    
    print("\nğŸ“ æ¸¬è©¦æ¡ˆä¾‹ 3: è¶…ç´šè¤‡é›œå¤šå±¤åµŒå¥— (ä¿®æ­£ç‰ˆ)")
    excel_formula_formatter_v2(test_case_3, verbose=True)
    
    print("\n" + "-" * 60)
    
    # æ¸¬è©¦æ¡ˆä¾‹ 4: ç¾ä»£å‡½æ•¸
    test_case_4 = r"""=@FILTER(SORT(UNIQUE(XLOOKUP(SEQUENCE(10),INDEX('[modern.xlsx]Data'!A:A,0),INDEX('[modern.xlsx]Data'!B:B,0))),1,TRUE),XLOOKUP(SEQUENCE(10),INDEX('[modern.xlsx]Data'!A:A,0),INDEX('[modern.xlsx]Data'!C:C,0))>0)"""
    
    print("\nğŸ“ æ¸¬è©¦æ¡ˆä¾‹ 4: ç¾ä»£ Excel å‡½æ•¸çµ„åˆ")
    excel_formula_formatter_v2(test_case_4, verbose=True)


def quick_format_v2(formula: str) -> str:
    """å¿«é€Ÿæ ¼å¼åŒ–å‡½æ•¸ V2"""
    formatter = ExcelFormulaFormatterV2(verbose=False)
    _, formatted = formatter.format_excel_formula(formula)
    return formatted


def detailed_format_v2(formula: str) -> None:
    """è©³ç´°æ ¼å¼åŒ–å‡½æ•¸ V2"""
    excel_formula_formatter_v2(formula, verbose=True)


if __name__ == "__main__":
    print("ğŸš€ Excel å…¬å¼æ ¼å¼åŒ–å¼•æ“ V2 - é‡å¯«ç‰ˆ")
    print("âœ¨ æ–°å¢åŠŸèƒ½ï¼šåŸå§‹å…¬å¼å°æ¯”ã€æ”¹å–„è§£æé‚è¼¯")
    print("=" * 80)
    
    test_complex_formulas_v2()
    
    print("\n" + "=" * 80)
    print("ğŸ¯ å¼•æ“ä½¿ç”¨ç¤ºç¯„")
    print("=" * 80)
    
    print("åœ¨å…¶ä»–ç¨‹å¼ä¸­ä½¿ç”¨æ–¹æ³•:")
    print("```python")
    print("from excel_formula_formatter_v2 import excel_formula_formatter_v2, quick_format_v2")
    print("")
    print("# å®Œæ•´å°æ¯”æ ¼å¼åŒ–")
    print('excel_formula_formatter_v2("=SUM(A1:B10)", verbose=True)')
    print("")
    print("# å¿«é€Ÿæ ¼å¼åŒ–")
    print('result = quick_format_v2("=SUM(A1:B10)")')
    print("")
    print("# è©³ç´°æ¨¡å¼")
    print('detailed_format_v2(formula)')
    print("```")
